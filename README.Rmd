---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# poof

RStudio addins are great but have flaws :

* They're contained in packages, which are not straightforward to write/iterate on
* It's hard to remember which addins you've installed, and harder to remember the
hotkeys you've set for them
* The addin list soon becomes overwhelming

So you don't write them much, and you don't use them much.

{poof} is an attempt to solve those issues:

* It works with a single hotkey
* Only relevant action choices are proposed, depending on what was selected in the editor
* It's made very easy to add actions
* You can leverage existing installed addins

We don't recommend attaching the package, the namespace notation `poof::fun`
will work fine and keep your workspace cleaner.

## Installation

``` r
remotes::install_github("moodymudskipper/poof")
```

## Examples

We call "tricks" the features implemented by {poof}, and use the following syntax
to define them :

```
poof::add_tricks("<name1>" = <condition1> ~ <action1>, "<name2>" = <condition2> ~ <action2>, ...)
```

* Tricks which have their condition verified will be proposed, and once selected
their action will be triggered.

Let's build as an example featuring:

* an action to edit our .RProfile, proposed when the selection is empty
* an action to trigger the reprex addin, proposed when valid code is selected 
* an action to allign comments, proposed when commented lines are selected
For example let's set up 3 tricks : 
* an action to run debugonce on the selected function 

The code will look as below:

```{r}
poof::add_tricks(
  "Edit '.Rprofile'" =
    selection_is_empty() ~     # condition : no selection
    usethis::edit_r_profile(), # action    : call packaged function 
  
  "Reprex selection" =
    selection_is_parsable(symbol_ok = FALSE) ~  # condition : selection is code
    call_addin("reprex", "Reprex selection"),   # action    : call existing addin

  "allign comments" =
    # condition : selection, extended to full lines, contains at least 2 comments
    selection_contains_string("#", n_min = 2, target = "lines") ~
    # action    : write custom code to replace current one
    local({
      code <- current_lines()
      pos <- regexpr("#", code)
      pad <- max(pos) - pos
      code <- mapply(function(x, n) sub("#", paste0(strrep(" ", n), "#"), x), code, pad)
      replace_current_lines(code)
    }),
  
  # name : here using glue syntax to have dynamic action names
  "debugonce({current_selection()})" = 
    # condition : selection evaluates to function
    selection_is_function() ~ 
    # action    : run debugonce, we use `bquote()`'s `.()` notation to work around NSE issues
    debugonce(.(current_call())),      
)
```


![](man/figures/poof1.gif)

`selection_is_empty()` and `selection_is_parsable()` are condition helpers, 
they return `TRUE` or `FALSE`. There are more of them and they're documented in `?"condition-helpers"`. 

Here are some of them : 

```{r}
selection_is_empty
selection_is_comment_block
selection_is_call
selection_is_function
selection_is_data_frame
selection_inherits
selection_is_in_rmd_chunk
selection_is_in_rmd_text
selection_is_symbol
selection_is_syntactic_package_name
selection_is_cran_package
selection_is_installed_package
current_file_is_r_script
current_file_is_rmd
clipboard_contains_text
clipboard_is_parsable
clipboard_text
project_is_package
project_uses_git
system_has_internet
```

`current_lines()` is a selection helper, selection helpers return an output related
to the selection, some more examples are:

```{r}
current_selection
current_call
current_value
current_code_block
current_expr
current_path
```

`replace_selection()` and  `call_addin()` are action helpers and they're documented in `?"action-helpers"`


![](man/figures/poof2.gif)

And let's illustrate `.val` and `.sub` with a last example, a trick to `debugonce`
the selected function : 

* We'd like the name of the item to depend on the selection so we use a glue string
* It should be considered only when selecting a function so
we'll have a condition on the value `.val`
* The action uses the function `debugonce()` which uses non standard evaluation,
 but this is made easy using `.sub`.
 
 
```{r}
poof::add_tricks(
  "debugonce({.txt})" =  # use a glue string to have a dynamic item name
    is.function(.val) ~  # consider only selection that evaluates to a function 
    debugonce(.sub)      # run function, by substituting the selection in the action
)
```

![](man/figures/poof3.gif)

Note: 



Since the conditions are all evaluated for each trick each time the addin is triggered
we need to make sure these don't have side effects such as changing the 
environment or writing to disk. `.val` is dangerous
in this respect as it triggers the evaluation of the selection. For this reason
tricks containing `.val` in the selection are considered only if the selection is
a symbol or a call to `::`, `:::`, `$`, `[` or `[[`.

## Where are these tricks stored ?

They're stored in the `"poof.tricks"` option which you can display with `getOption("poof.tricks")`
or `poof::show_tricks()`. We've shown how to add tricks, you can also remove some
by using `poof::rm_tricks()`.

You might want to place a `poof::add_tricks()` call in your R Profile, or design
your own custom function to call it.

## Some more examples ?

*Soon*
